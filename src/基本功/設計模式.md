# 設計模式學習筆記

> A pattern is a proven solution to a recurring problem in a specific context.
> 模式是在一個特定情境下針對重複出現的問題的一個成熟的解決方案

## 物件導向設計基本原則 SOLID

Robert C. Martin 提出的物件導向五個原則，這五個設計原則都是針對「應付改變」這件事

* S：單一職責原則 (Single*Responsibility Principle, SRP)
    * There should never be more than one reason for a class to change. (不應該有超過一個修改一個類別的理由)
        * 若要達成這個要求，那麼一個類別就應該只有一個功能(職責)，否則就有可能因為不只一個理由而改變。
    * 好處是因為類別只有一個功能，這樣可以降低單一類別被改變時影響的範圍
    * 根據「單一職責原則」，將一個系統劃分為若干個子系統有利於降低整個系統的複雜性，一個常見的設計目標是使子系統間的通信和相互依賴關係達到最小，而達到該目標的途徑之一就是引入一個外觀對象，它為子系統的訪問提供了一個簡單而單一的入口。
* O：開放封閉原則 (Open*Close Principle, OCP)
    * Open for extension, but closed for modification (對擴充開放，但對修改封閉)
    * 新增需求時，盡可能讓所有修改擴充都是「新增程式碼」而不是「修改程式碼」。
        * 開發軟體最怕的不是「寫程式」而是「改程式」，因為一旦改動，所有相依的模組都可能需要修改，就有可能出問題。
            * 雖然如果有足夠的測試可以減少這種「漣波效應（ripple effect）」，但如果能完全避免掉這種效應當然更好。避免的方式最簡單的就是－－只新增程式碼，不修改任何舊有的程式碼，既然沒修改，自然不會有漣波效應。
    * 要做到這一點，實作就必須符合 LSP 原則才行。
* L：立次克夫替換原則 (Liskov Substitution Principle)
    * Subtypes must be substitutable for their base types (只要是父類別(介面)出現的地方，都可以用子類別(介面實作)取代)
        * 也就是說子類別要有與父類別一致的行為，反過來說，父類別(介面)必須遵守定義介面的人所期待的行為。
    * 針對繼承時子類別所造成的「行為變化」要如何設計的原則
* I：介面隔離原則 (Interface segregation principle, ISP)
    * 客戶端不應依賴它不需要的介面，類別之間的依賴應該建立在最小的介面上，避免客戶端因為不相關介面改變也一起被迫需要改變。
        * 也就是說不應該用大的總體介面，而是用較小的專門介面，介面的方法盡可能少，減少改變的機會。
* D：依賴倒轉原則 (Dependency*Inversion Principle, DIP)
    * 又稱「相依性反向原則」、「依存關係反轉原則」...
    * High-level modules should not depend on low-level modules. Both should depend on abstractions. (高層模組不應該依賴低層模組，兩個都應該依賴抽象)
    * Abstractions should not depends on details. Details should depend on abstractions. (抽象不應該依賴細節，細節應該依賴抽象)
    * 正常情況下，上層模組自然會相依於下層模組(因為上層模組會用到下層模組的功能)，但 DIP 告訴我們要變成「上層和與下層模組都相依於抽象介面(abstractions)，這樣上層模組就不會因為底層模組改變而被迫改變。白話文的說就是依賴抽象，而不是具體實現，另一個說法－－細節依賴策略，而策略不依賴細節。
    * 這種設計方式也符合開放封閉原則 (Open*Closed Principle)

## 領域驅動設計 (Domain-Driven Design, DDD)

可以看到領域驅動設計（domin-driven design）不同於傳統的針對數據庫表結構的設計，領域模型驅動設計自然是以提煉和轉換業務需求中的領域知識為設計的起點。在提煉領域知識時，沒有數據庫的概念，亦沒有服務的概念，一切圍繞著業務需求而來，即：

* 現實世界有什麼事物 -> 模型中就有什麼對象
* 現實世界有什麼行為 -> 模型中就有什麼方法
* 現實世界有什麼關系 -> 模型中就有什麼關聯

DDD 按照單一職責原則（Single responsibility principle）進行領域建模，軟件系統中每個元素只完成自己職責內的事，將其他的事交給別人去做。

我們需要根據業務相關性、耦合的強弱程度、分離的關注點對這些活動進行歸類，找到不同類別之間存在的邊界，這就是限界上下文的含義。上下文（Context）是業務目標，限界（Bounded）則是保護和隔離上下文的邊界，避免業務目標的不單一而帶來的混亂與概念的不一致。

DDD 的大體流程如下：

1. 建立統一語言
    * 統一語言是提煉領域知識的產出物，獲得統一語言就是需求分析的過程，也是團隊中各個角色就系統目標、范圍與具體功能達成一致的過程。
    * 使用統一語言可以幫助我們將參與討論的客戶、領域專家與開發團隊拉到同一個維度空間進行討論，若沒有達成這種一致性，那就是雞同鴨講，毫無溝通效率，相反還可能造成誤解。因此，在溝通需求時，團隊中的每個人都應使用統一語言進行交流。
    * 一旦確定了統一語言，無論是與領域專家的討論，還是最終的實現代碼，都可以通過使用相同的術語，清晰准確地定義領域知識。重要的是，當我們建立了符合整個團隊皆認同的一套統一語言後，就可以在此基礎上尋找正確的領域概念，為建立領域模型提供重要參考。
        * 舉個例子，不同玩家對於英雄聯盟（league of legends）的稱呼不盡相同；國外玩家一般叫“League”，國內玩家有的稱呼“擼啊擼”，有的稱呼“LOL”等等。那麼如果要開發相關產品，開發人員和客戶首先需要統一對“英雄聯盟”的語言模型。
2. 事件風暴（Event Storming）
    * 事件風暴會議是一種基於工作坊的實踐方法，它可以快速發現業務領域中正在發生的事件，指導領域建模及程序開發。它是 Alberto Brandolini 發明的一 種領域驅動設計實踐方法，被廣泛應用於業務流程建模和需求工程，基本思想是將軟件開發人員和領域專家聚集在一起，相互學習，類似頭腦風暴。
    * 會議一般以探討領域事件開始，從前向後梳理，以確保所有的領域事件都能被覆蓋。
        * 領域事件是領域模型中非常重要的一部分，用來表示領域中發生的事件。一個領域事件將導致進一步的業務操作，在實現業務解耦的同時，還有助於形成完整的業務閉環。
        * 領域事件可以是業務流程的一個步驟，比如投保業務繳費完成後，觸發投保單轉保單的動作；也可能是定時批處理過程中發生的事件，比如批處理生成季繳保費通知單，觸發發送繳費郵件通知操作；或者一個事件發生後觸發的後續動作，比如密碼連續輸錯三次，觸發鎖定賬戶的動作。

3. 進行領域建模，將各個模型分配到各個限界上下文中，構建上下文地圖。
領域建模時，我們會根據場景分析過程中產生的領域對象，比如命令、事件等之間關系，找出產生命令的實體，分析實體之間的依賴關系組成聚合，為聚合劃定限界上下文，建立領域模型以及模型之間的依賴。

## 寫入時複製 Copy-On-Write

好文參考：

* [让 Node.js 变“懒”的 COW 技术](https://mp.weixin.qq.com/s/nQ6wHZ4H7ULcvN-rwLP-GA?utm_source=pocket_mylist)

## 參考文章

* [領域驅動設計 ( DDD) 能給前端帶來什麼](https://mp.weixin.qq.com/s/Pp_H8ijxjZmCJCx753LmXQ)