# 設計模式學習筆記

> A pattern is a proven solution to a recurring problem in a specific context.
> 模式是在一個特定情境下針對重複出現的問題的一個成熟的解決方案

## 物件導向設計基本原則 SOLID

Robert C. Martin 提出的物件導向五個原則，這五個設計原則都是針對「應付改變」這件事

* S：單一職責原則 (Single*Responsibility Principle, SRP)
    * There should never be more than one reason for a class to change. (不應該有超過一個修改一個類別的理由)
        * 若要達成這個要求，那麼一個類別就應該只有一個功能(職責)，否則就有可能因為不只一個理由而改變。
    * 好處是因為類別只有一個功能，這樣可以降低單一類別被改變時影響的範圍
    * 根據「單一職責原則」，將一個系統劃分為若干個子系統有利於降低整個系統的複雜性，一個常見的設計目標是使子系統間的通信和相互依賴關係達到最小，而達到該目標的途徑之一就是引入一個外觀對象，它為子系統的訪問提供了一個簡單而單一的入口。
* O：開放封閉原則 (Open*Close Principle, OCP)
    * Open for extension, but closed for modification (對擴充開放，但對修改封閉)
    * 新增需求時，盡可能讓所有修改擴充都是「新增程式碼」而不是「修改程式碼」。
        * 開發軟體最怕的不是「寫程式」而是「改程式」，因為一旦改動，所有相依的模組都可能需要修改，就有可能出問題。
            * 雖然如果有足夠的測試可以減少這種「漣波效應（ripple effect）」，但如果能完全避免掉這種效應當然更好。避免的方式最簡單的就是－－只新增程式碼，不修改任何舊有的程式碼，既然沒修改，自然不會有漣波效應。
    * 要做到這一點，實作就必須符合 LSP 原則才行。
* L：立次克夫替換原則 (Liskov Substitution Principle)
    * Subtypes must be substitutable for their base types (只要是父類別(介面)出現的地方，都可以用子類別(介面實作)取代)
        * 也就是說子類別要有與父類別一致的行為，反過來說，父類別(介面)必須遵守定義介面的人所期待的行為。
    * 針對繼承時子類別所造成的「行為變化」要如何設計的原則
* I：介面隔離原則 (Interface segregation principle, ISP)
    * 客戶端不應依賴它不需要的介面，類別之間的依賴應該建立在最小的介面上，避免客戶端因為不相關介面改變也一起被迫需要改變。
        * 也就是說不應該用大的總體介面，而是用較小的專門介面，介面的方法盡可能少，減少改變的機會。
* D：依賴倒轉原則 (Dependency*Inversion Principle, DIP)
    * 又稱「相依性反向原則」、「依存關係反轉原則」...
    * High-level modules should not depend on low-level modules. Both should depend on abstractions. (高層模組不應該依賴低層模組，兩個都應該依賴抽象)
    * Abstractions should not depends on details. Details should depend on abstractions. (抽象不應該依賴細節，細節應該依賴抽象)
    * 正常情況下，上層模組自然會相依於下層模組(因為上層模組會用到下層模組的功能)，但 DIP 告訴我們要變成「上層和與下層模組都相依於抽象介面(abstractions)，這樣上層模組就不會因為底層模組改變而被迫改變。白話文的說就是依賴抽象，而不是具體實現，另一個說法－－細節依賴策略，而策略不依賴細節。
    * 這種設計方式也符合開放封閉原則 (Open*Closed Principle)

## 寫入時複製 Copy-On-Write

好文參考：

* [让 Node.js 变“懒”的 COW 技术](https://mp.weixin.qq.com/s/nQ6wHZ4H7ULcvN-rwLP-GA?utm_source=pocket_mylist)
